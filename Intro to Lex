# What is Lex?
->  Lex is a tool for lexical analysis.
    You define patterns (regular expressions) that match parts of the input.
    And for each match, Lex executes some code you specify.

# Structure of a Lex Program:
->  A Lex program consists of three sections:
    1. Definition Section: Declare variables and include headers like #include <stdio.h>.
    2. Rules Section: Define patterns and corresponding actions.
    3. User Code Section: Write supporting code like the main() function.

# Lex Rules and Syntax Guide

## Basic Structure
```
Definitions Section
%%
Rules Section
%%
User Code Section
```

## 1. Definitions Section Syntax

### Variable Declarations
- Must be enclosed in %{ and %}
- Example:
  ```
  %{
  int count = 0;
  #include <stdio.h>
  %}
  ```

### Pattern Definitions
- Format: name pattern
- Must start at beginning of line
- Example:
  ```
  DIGIT    [0-9]
  LETTER   [a-zA-Z]
  ```

### Start States Declaration
- Format: %x statename
- Used for context-sensitive scanning
- Example:
  ```
  %x COMMENT
  %x STRING
  ```

## 2. Rules Section Syntax

### Basic Rule Format
- pattern { action }
- Pattern must start at beginning of line
- Action must be in curly braces
- Example:
  ```
  [0-9]+  { printf("Found number: %s\n", yytext); }
  ```

### Pattern Writing Rules
- Regular expressions are used for patterns
- Special characters: . * + ? [ ] ^ $ ( ) { } | \ / "
- Must escape these with \ to match literally
- Common patterns:
  - . : any character except newline
  - [abc] : character class
  - [^abc] : negated character class
  - r* : zero or more of r
  - r+ : one or more of r
  - r? : zero or one of r
  - r{n,m} : n to m occurrences of r
  - r1|r2 : either r1 or r2
  - (r) : grouping
  - ^r : r at start of line
  - r$ : r at end of line

### Action Writing Rules
- C code enclosed in { }
- Special variables available:
  - yytext: matched text
  - yyleng: length of match
  - yylineno: current line number
- Special functions:
  - ECHO: print matched text
  - BEGIN(state): switch to start state
  - REJECT: try next pattern
  - yymore(): append next match
  - yyless(n): push back input
  - input(): get next character
  - unput(c): push back character

### Start State Rules
- <STATE>pattern { action }
- Example:
  ```
  <COMMENT>"*/"    { BEGIN(INITIAL); }
  ```

## 3. User Code Section Requirements

### Minimum Requirements
- Must include main()
- Must include yywrap() or link with -ll

### Common Functions
```c
int main() {
    yylex();
    return 0;
}

int yywrap() {
    return 1;
}
```

## Important Operational Rules

1. Pattern Matching Priority
   - Longest match wins
   - If same length, first rule wins
   - More specific patterns should come before general ones

2. Default Actions
   - If no action specified, matched text is printed
   - If no pattern matches, character is copied to output

3. Error Handling
   - Use error patterns to catch unexpected input
   - . pattern can catch anything not matched
   - Example:
     ```
     .  { printf("Error: unexpected character %s\n", yytext); }
     ```

4. Memory Management
   - yytext is overwritten by each match
   - Copy yytext if you need to save it
   - Use strdup() or similar if storing matches

5. Input/Output Control
   - yyin: input file pointer (default stdin)
   - yyout: output file pointer (default stdout)
   - Can reassign these in main()
   - Example:
     ```c
     yyin = fopen("input.txt", "r");
     yyout = fopen("output.txt", "w");
     ```

## Common Pitfalls to Avoid

1. Not ordering patterns from most specific to most general
2. Forgetting to escape special characters
3. Not handling all possible input cases
4. Assuming yytext persists between matches
5. Using ^ or $ incorrectly in patterns
6. Forgetting to include necessary header files
7. Not properly closing files opened in user code